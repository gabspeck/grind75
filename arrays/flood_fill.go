package arrays

// You are given an image represented by an m x n grid of integers image, where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and color. Your task is to perform a flood fill on the image starting from the pixel image[sr][sc].
//
// To perform a flood fill:
//
//	Begin with the starting pixel and change its color to color.
//	Perform the same process for each pixel that is directly adjacent (pixels that share a side with the original pixel, either horizontally or vertically) and shares the same color as the starting pixel.
//	Keep repeating this process by checking neighboring pixels of the updated pixels and modifying their color if it matches the original color of the starting pixel.
//	The process stops when there are no more adjacent pixels of the original color to update.
//
// Return the modified image after performing the flood fill.
type FloodFillFunc func(image [][]int, sr, sc, color int) [][]int

// FloodFillAttemptRecursive uses recursion to change the pixel values... not ideal because of stack overflow risks for larger images
func FloodFillAttemptRecursive(image [][]int, sr, sc, color int) [][]int {
	oldColor := image[sr][sc]

	if oldColor == color {
		return image
	}

	image[sr][sc] = color
	if sr+1 < len(image) && image[sr+1][sc] == oldColor {
		FloodFillAttemptRecursive(image, sr+1, sc, color)
	}
	if sr-1 >= 0 && image[sr-1][sc] == oldColor {
		FloodFillAttemptRecursive(image, sr-1, sc, color)
	}
	if sc+1 < len(image[sr]) && image[sr][sc+1] == oldColor {
		FloodFillAttemptRecursive(image, sr, sc+1, color)
	}
	if sc-1 >= 0 && image[sr][sc-1] == oldColor {
		FloodFillAttemptRecursive(image, sr, sc-1, color)
	}

	return image
}

// FloodFillAttemptIterative uses a stack to implement an iterative approach to flood filling.
func FloodFillAttemptIterative(image [][]int, sr, sc, color int) [][]int {
	oldColor := image[sr][sc]

	if oldColor == color {
		return image
	}

	pixelStack := [][]int{{sr, sc}}

	for len(pixelStack) > 0 {
		pixel := pixelStack[len(pixelStack)-1]
		r := pixel[0]
		c := pixel[1]

		pixelStack = pixelStack[0 : len(pixelStack)-1]
		image[r][c] = color
		if r-1 >= 0 && image[r-1][c] == oldColor {
			pixelStack = append(pixelStack, []int{r - 1, c})
		}
		if r+1 < len(image) && image[r+1][c] == oldColor {
			pixelStack = append(pixelStack, []int{r + 1, c})
		}
		if c-1 >= 0 && image[r][c-1] == oldColor {
			pixelStack = append(pixelStack, []int{r, c - 1})
		}
		if c+1 < len(image[r]) && image[r][c+1] == oldColor {
			pixelStack = append(pixelStack, []int{r, c + 1})
		}
	}

	return image
}

// FloodFillAttemptIterativeOptimized optimizes on FloodFillAttemptIterative by immediately assigning the new color to popped pixels
func FloodFillAttemptIterativeOptimized(image [][]int, sr, sc, color int) [][]int {
	oldColor := image[sr][sc]

	if oldColor == color {
		return image
	}

	rows, cols := len(image), len(image[0])

	image[sr][sc] = color
	pixelStack := [][]int{{sr, sc}}

	for len(pixelStack) > 0 {
		pixel := pixelStack[len(pixelStack)-1]
		r := pixel[0]
		c := pixel[1]

		pixelStack = pixelStack[0 : len(pixelStack)-1]
		if r-1 >= 0 && image[r-1][c] == oldColor {
			image[r-1][c] = color
			pixelStack = append(pixelStack, []int{r - 1, c})
		}
		if r+1 < rows && image[r+1][c] == oldColor {
			image[r+1][c] = color
			pixelStack = append(pixelStack, []int{r + 1, c})
		}
		if c-1 >= 0 && image[r][c-1] == oldColor {
			image[r][c-1] = color
			pixelStack = append(pixelStack, []int{r, c - 1})
		}
		if c+1 < cols && image[r][c+1] == oldColor {
			image[r][c+1] = color
			pixelStack = append(pixelStack, []int{r, c + 1})
		}
	}

	return image
}

// FloodFillReference is a reference solution generated by Claude
func FloodFillReference(image [][]int, sr int, sc int, color int) [][]int {
	// Get the original color at the starting position
	originalColor := image[sr][sc]

	// If the original color is already the target color, no changes needed
	if originalColor == color {
		return image
	}

	// Get the dimensions of the image
	rows := len(image)
	cols := len(image[0])

	// Define a helper function to perform DFS
	var dfs func(r, c int)
	dfs = func(r, c int) {
		// Check if current position is out of bounds
		if r < 0 || r >= rows || c < 0 || c >= cols {
			return
		}

		// Check if current pixel has the original color
		if image[r][c] != originalColor {
			return
		}

		// Update the color of the current pixel
		image[r][c] = color

		// Recursively visit all four adjacent pixels
		dfs(r+1, c) // Down
		dfs(r-1, c) // Up
		dfs(r, c+1) // Right
		dfs(r, c-1) // Left
	}

	// Start DFS from the given position
	dfs(sr, sc)

	// Return the modified image
	return image
}
